C O D I N G   S T Y L E
-----------------------
-----------------------



##################
Shortest Manifesto
##################

Shorten the time from reading to understanding.



###############
Short Manifesto
###############

Brevity is good, clarity is better.
Names are important.
Visual patterns are good.
Interdependencies should be near.
Speakable English sentences are good.



###############
PEP8 Amendments
###############

Use whitespace to reveal meaningful patterns
--------------------------------------------

Probably not:

x             = 1
y             = 2
long_variable = 3


Probably:

x             = long_function_name(1)
y             = long_function_name(2)
long_variable = long_function_name(3)



Rationale:  visual patterns enhance understanding.
Specifically rejecting these warnings:
    PEP8: E202 whitespace before ')'
    PEP8: E222
    PEP8: E231 missing whitespace after ','
    PEP8: E251
    PEP8: E305




120 Wide
--------

Limit all lines to 119 characters, whether code or comments.  
PyCharm defaults to this (Settings | Editor | Code Style | Right margin).

Limit lines in docstrings and help messages (e.g. argparse description) to 72 characters.  
This is an end-user limitation, and rightly more conservative than a developer limitation.

Possibly 100 is better.  At least on my portrait-oriented monitors, where 120 doesn't fit.




Function parameters
-------------------

Enclosed things (e.g. function parameters) should either be: 
    *  all on one line; or 
    *  one per line, indented at the same level.  (The lines with the brackets should be outdented.)

Yes:

    y = f(x)

    y = f(x1, x2, x3)

    y = f(
        x1,
        x2,
        x3
    )

    y = f(
        x1,
        x2,
        g(y1, y2, y3)
    )

    y = f(
        x1,
        x2,
        g(
            y1,
            y2,
            y3
        )
    )

No:

    y = f(
        x1,
        x2,
        x3)

    y = f(x1,
          x2,
          x3
    )

    y = f(
        x1, x2,
        long_variable
    )

    y = f(x1, x2, x3, x_running_out_of_line_width,
          long_variable)
    
Goes for function call or definition, and members of a literal tuple, list, dict, or set.

This convention is borrowed from PHP coding standard PSR-2, section 4.6, Method and Function Calls.
https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#user-content-46-method-and-function-calls

SEE:  multiline statements in Python, http://stackoverflow.com/a/4172465/673991

Counterpoint:
    lots_of_little_things = [
         2,   3,   5,   7,  11,  13,  17,  19, 
        23,  29,  31,  37,  41,  43,  47,  53, 
        59,  61,  67,  71,  73,  79,  83,  89, 
        97, 101, 103, 107, 109, 113, 127, 131, 
    ]



Answer-then-Question
--------------------
assertEquals(expected_value, computed_value)

Yes:
    assert expected_return == f(x, y)
No:
    assert f(x, y)) == expected_return

Rationale:  This is the order of use in the wild, so that mental model should be reinforced:

    actual_return = f(x, y)

Counterpoint:  if variable_name == literal_value   # (The difference is, variable_name is not being computed here.)



Explicit Package Names
----------------------

Yes:
    import binascii
    :
    hex = binascii.hexlify(bin)

No:
    from binascii import hexlify
    :
    hex = hexlify(bin)

This guy concurs:  http://programmers.stackexchange.com/a/187471/56713

Counterpoint:
    aggregated packages
        example:  from qiki import Number
    deep nesting:
        example:  from package.sub.subsub.subsubsub import module
        example:  from django.http import HttpResponse
    package name is more ephemeral than the object name
        example:  from bs4 import BeautifulSoup
    packages that hide their influence for noble reasons
        example:  from __future__ import print_function



Alphabetize imports, within the three PEP8 sections
---------------------------------------------------
No:
    import collections
    import binascii
    import array

    import coconut
    import bungee
    import anvil
Yes:
    import array
    import binascii
    import collections
    
    import anvil
    import bungee
    import coconut


Import one module per line
--------------------------
Good:
    from django.http import HttpResponse
    from django.http import Http404

Not as good:
    from django.http import HttpResponse, Http404

Rationale:
    easier to delete, comment-out, etc., and so less error-prone
    visual repetition is good


Double Quotes for Humans, Single Quotes for Machines
----------------------------------------------------
Use "double quotes" for strings that are to be seen by humans.  

    print("All is well.")
    raise("This should never have happened.")

Strings with functional consequences should use 'single quotes'.  The only humans likely to see them are programmers.

    if __name__ == '__main__':
        main(port='COM3')

    serial_port.write('ATDT555-1212')
    
Double quoted strings can be changed without breaking the code.

"""docstrings"""
'''other multi-line comments'''   <-- Does that fit the pattern or buck it?  
                                      Both are for human consumption and changes will not break.



.format() over %
----------------

.format() is better than %.  The syntax and options are harder to remember, but if you tell people that's because
they're too old, they should complain less.  If that doesn't do it, suggest their first programming language must 
have been Fortran.


.format() without numbers
-------------------------
A single unnamed argument is okay.

    "The parrot is {}.".format("resting")

Otherwise, use named formatting arguments.  

    "The {something} in {other_thing}".format(something="rain", other_thing="Spain")

Never use numbered "positional" arguments.

    "He's not {0}, he's {1}!".format("resting", "dead")



dict() over {} (unsure about this one)
--------------

Okay:   {'key': 'value'}
Better: dict(key='value')

Okay:
    { 
        'key': 'value',
        'name': 'value',
    }
Better:
    dict(
        key='value',
        name='value',
    )


Obviously there's a tradeoff in clutter.  Another advantage of dict() is the syntax highlighting of the key names. But the curly-syntax is more versatile.

Counter-arguments:
    You cannot do:

        dict(class='value')
        dict(3='three')

    You could instead:
    
        { 'class': 'value' }
        { 3: 'three' }


    Sure looks nice:
        d = {}



Doc string
----------

Yes:

    """This is 1 line."""


    """
    This is the first line.

    This is the second line.
    """

No:

    """This is the first line.
    
    This is the second line."""


    """Sentence fragment."""



Weird-behaving code should be weird-looking
-------------------------------------------

    Slice Colon -- room to breathe
    ------------------------------
    Exactly one space (even if shared) before and after each slice colon.
    There should be a spece whether or not the slice parameter is omitted.  In other words, 
    cancel the exception in PEP8 that reads "when a slice parameter is omitted, 
    the space is omitted")

    Yes:
        ham[1 : 9], ham[1 : 9 : 3], ham[ : 9 : 3], ham[1 : : 3], ham[1 : 9 : ], ham[ : : 2]

    No:
        ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:], ham[::2]



    Tuple assignment -- use parentheses
    -----------------------------------
    no:
        width, height = dimensions()
    yes:
        (width, height) = dimensions()

    no:
        for key, value in zip(keys, values):
    yes:
        for (key, value) in zip(keys, values):
        
    Supports search for tuple-assignment:  ") :"
    
    Rebuttal:  We don't do this for return because that generates 
    a weak warning in PyCharm about redundant parens.
    
    yes:
        return key, value
    meh:
        return (key, value)



Avoid 'pass'
------------
THANKS:  Should document exception, http://code.activestate.com/lists/python-ideas/14893/
No:
    class SpecialError(Exception):
        pass
Yes:
    class SpecialError(Exception):
        """Why would this happen?  Example:  bad_function_call()"""

No:
    try:
        risky_behavior()
    except:
        pass
Yes:
    try:
        risky_behavior()
    except:
        """Why we're letting this pass.  Example when it happens."""
        
        
Enumerate with class "constants" and an all-caps class name
-----------------------------------------------------------
No:
    FRUIT_APPLE = 1
    FRUIT_BANANA = 2
    FRUIT_CHERRY = 3
    
    print(FRUIT_BANANA)

Yes:
    class FRUIT(object):
        APPLE = 1
        BANANA = 2
        CHERRY = 3
        
    print(FRUIT.BANANA)
        
        

Custom Exception or RuntimeError
--------------------------------
Raised exceptions should have a programmer-readable message.
Raising a custom exception is better than raising a built-in exception.
A custom exception class would be better derived from a built-in exception class, 
    rather than the generic Exception.  
A custom exception class should have a name that ends in "Error" 
    following the convention of all built-in exception classes.
You can raise a RuntimeError in reusable code on an extraordinary event 
    that a client shouldn't be expected to anticipate, 
    but which could be very hard to debug if execution proceeded.
    E.g. someone must have broken the reusable code 
        (in which case one of its unit tests should fail)
    E.g. there's a bug in Python.
    This can help document a non-obvious assumption, e.g. a side-effect of a built-in function
        perhaps to forestall refactoring that would break,

No:
    def foo(bar):
        if problem:
            raise ValueError
            
Yes:
    def foo(bar):
        if problem:
            raise FooAbuseError("What went wrong in this case.")
    
    class FooAbuseError(Exception):
        """What this exception means.  Example foo(data_that_could_cause_it)"""
        

Commas Forever (MAYBE, NOT SO SURE ABOUT THIS)
--------------
Every literal tuple or list or dict should put a comma after its last member.

No:
    (1,2,3)
Yes:
    (1,2,3,)
    
Avoids bugs where (1) is simple parentheses, not a tuple.


What is important should stand out
----------------------------------
Ok:
    var $elements = $(
        '.long-class-name ' + 
        '.another-long-class-name'
    )
Better:
    var $elements = $(
        '.long-class-name' +
        ' ' + 
        '.another-long-class-name'
    )


Continuation Lines:  parentheses preferred, backslash bashed
------------------
Long atomic lines must be split.  But line terminators in Python have syntactic power, unlike C or Java.
Backslashes are possible but parentheses look better. For emotional reasons I haven't rationalized yet.

    Nah:
        request['LandedCostRequest']['QueryRequest']['Shipment']['DestinationStateProvinceCode'] = \
            shipment['ShipTo']['Address']['StateProvinceCode']
        # readable, but jarring for some reason
    Yeah:
        request['LandedCostRequest']['QueryRequest']['Shipment']['DestinationStateProvinceCode'] = (
            shipment['ShipTo']['Address']['StateProvinceCode']
        )
        # very clear what's happening
    Ooh ooh:
        (
            request
                ['LandedCostRequest']
                ['QueryRequest']
                ['Shipment']
                ['DestinationStateProvinceCode']
        ) = (
            shipment
                ['ShipTo']
                ['Address']
                ['StateProvinceCode']
        )
        # possibly even clearer what's happening
    Meh:
        new_query = request['LandedCostRequest']['QueryRequest']
        old_province = shipment['ShipTo']['Address']['StateProvinceCode']
        new_query['Shipment']['DestinationStateProvinceCode'] = old_province
        # very difficult to read


import sections
---------------
PEP8 identifies 3 sections for imports:  standard, pypi, local.  Single blank lines between each section. The middle pypi section should be further broken down, because many times it includes lots of related imports.  And sometimes it needs logic or verbose comments on all the difficulties.


Three Spaces before comments
Three Spaces between multi-line lines
-------------------------------------
Comments should be uncommon.  Most should have their own line.  
End-of-line comments should be at least 3 spaces from code.
Inline comments should be rare.

No:
    hot(mess) # even hotter
Yes:
    cool(breeze)   # is cool

Multi-line lines should be rare.  But when they're there, give them some air.

No:
    f(x); g(y);
Yes:
    f(x);   g(y);
















###########################
JavaScript Coding Standards
###########################

READ:  http://javascript.crockford.com/code.html

$variable names for jQuery objects begin with a dollar sign.  
SEE:  http://stackoverflow.com/questions/6209462/when-why-to-prefix-variables-with-when-using-jquery

Stacked methods on the SAME jQuery object may be indented, and terminated by a single-line ';'

    $name_field
        .addClass('clout')
        .attr('maxlength', 50)
        .data('foo', 'bar')
    ;
    
Not sure about stacked methods that traverse DIFFERENT jQuery objects.

    // #1
    $form
        .find('#name')
        .closest('.address')
        .addClass('red-ring')
    ;
    
Should this instead be:

    // #2
    var $name = $form.find('#name');
    var $address = $name.closest('address');
    $address.addClass('red-ring');
    
Pros to #1:
    Brief
    Lines start with important method names, instead of burying them
Pros to #2:
    Clarity the progression of objects
    Clarity on which object each method is being called on
    Cue that you cannot rearrange these lines

Leaning toward #2.
    
Hmm, here's an exception to the same-object rule:

    $good_names = $names
        .not('.bad')
        .not('#terrible')
    ;

    Leaning toward #1 in this case.  (In part because you CAN rearrange these lines.)


Event handlers should only be event handlers
--------------------------------------------
So never call an_event_handler() with parens.

Fine:
    $foo.on('click', foo_click_handler);
Not so fine:
    $foo.on('click', a_more_general_function);
Yes:
    $foo.on('click', function () { a_more_general_function(); });

This is an example of easing off on other principles:  brevity is sacrificed, and future development is considered.
The problem this addresses, comes from the sneaky way event handlers have special needs that aren't encapsulated.
E.g. `this` or window.event or evt.stopPropagation().
The general concept is that future evolution of a function is perilous if the function has complex expectations.
Being both an event handler and something else is complex.
In other words, once an event handler, always an event handler.

Multiple uses of the same event handler is fine, but name it clearly:

Nope:
    $foo.on('click', foo_click_handler);
    $bar.on('click', foo_click_handler);
Yep:
    $foo.on('click', foobar_ish_click_handler);
    $bar.on('click', foobar_ish_click_handler);


that = this
-----------
The `this` keyword should only appear in the first line of its function.

Yes:
    function click_handler() {
        var element = this;
        var $div = $(element).closest('div');
        :

Yes:
    Classy.prototype.method = function () {
        var that = this;
        that.other_method(that.property);
        :

Yes:
    property: { get: function () {return this.private_property;}}

When `this` appears throughout a method, it looks too dangerously much like `this` inside a function expression. A function expression looks like an innocent clause (if, for, while, etc.) but `this` means something different. 

Bug:
    handler: function () {
        this.count = 0;
        $('div').each(function () {
            this.count++;
        });
    }

Fix:
    handler: function () {
        var that = this;
        that.count = 0;
        $('div').each(function () {
            that.count++;
        });
    }

SEE:  `that` is the new `this`,  https://alistapart.com/article/getoutbindingsituations/#snippet26

I used to make an exception with constructors.  Two hours I'll never get back.

I almost thought I needed to make an exception with a // noinspection directive, 
that it needed to be the first line, above `that = this`.
but it was only to hide a warning that `that` was assigned but never used.  
So I just deleted the `that` assignment.
















#######
Generic
#######

Principles that could apply to most languages.



Human Readability
=================
The first priority for code is to function.  
    Machines should work reliably and give human users an easier life.
The second priority for code is accurate, quick comprehension by human readers.  
    Do not fool, do not confuse, do not burden.
    Surprises are usually bad, SEE:  https://en.wikipedia.org/wiki/Principle_of_least_astonishment



Visual patterns are good
------------------------
No:
    for i in range(3):
        something()
Yes:
    something()
    something()
    something()

But more than 3 repetitions and it becomes tedious to count. Probably not a good visual pattern.

This might be similar to "code formatting for emphasis," apparently decried by Ry- 
https://stackoverflow.com/users/707111/ry
"If you don’t use code formatting for emphasis, we can probably be friends."

Okay:
            $popup_screen.css({
                top:0, right:0, bottom:0, left:0,
                'z-index':0,
                'background-color':'rgba(0,0,0,0.33)'
            });

Better:
            $popup_screen.css({top:0, right:0, bottom:0, left:0});
            $popup_screen.css({'z-index':0});
            $popup_screen.css({'background-color':'rgba(0,0,0,0.33)'});

            // Each line is atomic. 
            // I believe this code is comprehended quicker,
            // because its obvious repetitiveness creates a visual pattern 
            // which reduces cognitive load.



Competing consistency
---------------------
Not sure on this:
    top:0, zIndex:0          -- consistent JavaScript, not quoting property names
    top:0, 'z-index':0       -- consistent CSS with JavaScript property naming   <== ended up doing this
    'top':0, 'z-index':0     -- consistent both ways, but quote clutter



Avoid Double Negatives
----------------------
Do not nest negativity.  Limit human readers to one level of negativity per line of code.
Similarly in English:  This would be the only sentence that deserved to use a double negative. But hey, it didn't need to either.


No:
    is_invalid = error()
    if not is_invalid:   # Double negatives are not painless.
        goodie()
Yes:
    is_valid = not error()
    if is_valid:
        goodie()

No:
    if (!good) {
        short code
    } else {   // Double negatives are not uncomplicated.
        very
        long
        code
    }
No:
    if (good) {
        very
        long
        code
    } else {   // This 'else' is far from its 'if', making code review tedious.
        short code
    }
Maybe:
    bad = !good;
    if (bad) {
        short code
    } else {
        very
        long
        code
    }
Yes:
    if (!good) {
        short code
    }
    if (good) {   // Sacrifice a little brevity and D.R.Y. for easier reading.
        very
        long
        code
    }

Counterpoint:  Double negatives can be good.

    Here is a double negative:
        idn_mismatch = false;
    It could mean either:
        idns match, or
        the idns aren't known, or
        the idns aren't expected to match
    


Comprehensibility trumps Brevity
---------------------------------
Okay:
                    var error_message = oembed.error;
                    if (cont.media_domain !== 'no_domain') {
                        error_message += " for '" + cont.media_domain + "'";
                    }
Better:
                    var error_message;
                    if (cont.media_domain === 'no_domain') {
                        error_message = oembed.error;
                    } else {
                        error_message = oembed.error + " for '" + cont.media_domain + "'";
                    }

The second way is less brief but faster to comprehend.  This is also an example of deliberate code redundancy (the `error_message = oembed.error` assignment) to make visual patterns.


Okay:    dom_object = $jquery_object[0];
Better:  dom_object = $jquery_object.get(0);
Best:    dom_object = dom_from_$($jquery_object);

The first way is visually obscure.  An important conversion should stand out more.  
I realize one could say the same about array dereferencing, 
an array is importantly different from an array element!
I would counter that a container of apples has the same smell as an apple.
But a jQuery object smells different than a DOM object.  
That's a more momentous conversion.  It should glare.
Though I concede that to some people, a jQuery object and a DOM object should not smell differently,
because they are abstractions for the same manifestations, 
at least in this case that abstraction is one HTML element.
But they're made by two different teams (JavaScript for browsers team, and jQuery team).
And if anything has a smell (not necessarily in a bad sense, haha PUIBIKIAW) it is a team.


Some use of fall-through is brief but misunderstanding-prone.  

Okay:
    if a:
        return x
    return None

A little better:

    if a:
        return x
    else:
        return None

Okay:
    if a:
        if b:
            yes()
        else:
            no()
            return x
    return None           # this statement is loaded with too much responsibility

A lot better:
    if a:
        if b:
            yes()
            return None   # explicit is better
        else:
            no()
            return x
    else:
        return None       # explicit is better

    

Creative questions?
-------------------

Meh:
    if not this or not that or not the_other_thing:
        do_something()
Yes:
    if this and that and the_other_thing:
        '''Do nothing in this special case.  Sacrifice brevity for easier reading.'''
    else:
        do_something()


Conversion function name should use "from" not "to"
---------------------------------------------------
No:
    mm = inch2mm(inches)
    mm = inches_to_mm(inches)

Yes:
    mm = mm_from_inches(inches)

    See how the 'mm's are close together and the 'inches' are close together.

Nah:
    mm = mm4inch(inches)

    No, because "millimeters for inches" could be misunderstood as the opposite of "millimeters from inches".
    Concede "four" sounds a teensy bit like "from".
    Concede "4" looks a teensy bit like an arrow pointing left.

Eesh:
    mm = mm_inch(inches)

    I suppose if brevity had unusual benefits, and the convention were well learned.

Maybe but no:
    mm = mm_fm_inches(inches)



Code >>> Documentation ('>>>' means 'is way better than')
----------------------
Subprinciples:
    assert as documentation
    Extract Variable


assert as documentation
-----------------------
Using assert to document is meaningful, precise, and reliable.

Even mildly experienced programmers think enough "in the language" to recognize meaning from a good example.
And if they do not, they should be grateful to you for encouraging them to think that way.
Soon, English will fade blurry for them and code will pop out.
(This mindset has its limitations:  https://xkcd.com/149/)

There is an added benefit to assert-based over comment-based documentation.
Not only does assert document in the lingua locale, it packs the added punch of automated confirmation.

These benefits are worth a little syntactic vinegar, e.g. for demonstrating a Python @staticmethod:

    Class C
        @staticmethod
        def sum(a, b):
            return a + b

        assert 4 == sum.__func__(2+2)

It's a shame this cannot be:

        assert 4 == sum(2+2)

But it is still better than nothing.
Thanks to Ben from Melbourne for sleuthing this funky ".__func__" technique.
See http://stackoverflow.com/a/12718272/673991

This only helps with static methods.  No assert can immediately follow the definition a class method or a regular method.
For example, this does not work immediately after the definition of a class function pack_integer (and still inside the class):
     assert b'\x00\xFF' == pack_integer.__self__.pack_integer.__func__(255, 2)
The function has no __self__ member there.  Outside and after the class definition, it does and it's set to the class itself.


Extract Variable
Introduce Explaining Variable
-----------------------------
http://refactoring.com/catalog/extractVariable.html
http://c2.com/cgi/wiki?IntroduceExplainingVariable
"Put the result of the expression, or parts of the expression, in a temporary variable with a name that explains the purpose."

No:
    fish(cut_bait())
    
Yes:
    chum = cut_bait()
    fish(chum)

No:
    y = f(g(x))    # Reason why we call g() first then f()
    
Yes:
    explain_why_we_call_g_first = g(x)
    y = f(explain_why_we_call_g_first)
    
Clarify misleading code, commenting as a last resort
----------------------------------------------------

For example, the CSS cursor property values.

    cursor: pointer;   /* pointing finger */
    cursor: default;   /* arrow */
    cursor: default;   /* I-beam */
    cursor: move;   /* 4-directional arrows */
    cursor: wait;   /* hourglass */
    
For example, a Python class method's __self__attribute:
    class_itself = class_function.__self__
    
Note how a little homage can be given to the misleading name, echoing it so as to reveal the tenuous connection to its meaning.
    cursor: pointer;   /* pointing finger */
    class_itself = class_function.__self__


Conversational
--------------
Comments and documentation should use complete, grammatical, English sentences that one human might actually speak to another.


Contractions and Apostrophes
----------------------------
Avoid contractions.

    No:
        can't
    Yes:
        cannot

Reason 1, a little help for non-native English speakers.
Reason 2, apostrophes (single-quote marks) in comments or message strings thwart searches and sometimes cause bugs.
Apostrophes are worthwhile when avoidance would be silly (two's complement, Pascal's Triangle).
Luckily the contraction "it's" is easy to replace with "it is".  And the possessive "its" has no apostrophe.


Idioms
------
Bias against idioms, to help non-native English speakers.  These can be especially tedious to translate.



Unambiguous Wording
-------------------
Avoid ambiguous wording.  Imagine your text passing through a cheap translator. 
Simple words are good, but big words may be more precise and may translate with less confusion.

Where precise understanding is important, single-meaning English words are better than multiple-meaning words.
Because language translators are less likely to confuse the meanings.
So sometimes arcane polysyllabic jargon is better than a conversational monosyllable.

    "unambiguous"
        5 syllables
        1 meaning:  "only one way to interpret it"
    "clear"
        1 syllable
        more than 5 meanings
            and the meaning of "clear" that's closest to "unambiguous" is less precise:  "it's obvious"

Avoid non-primary meanings of simple words.  "Clear" means primarily transparent.  Be biased against using its other meanings.


Code in Comments
----------------
If a code fragment is in a comment, nothing should follow it but the newline.

A comment line that contains only a line of code is good.

    # assert 4 == 2+2

A comment line with an English sentence, and then code, is okay.

    # We can rely on math.  assert 4 == 2+2

A command line with an English sentence that contains code at its end is okay,
but in that case forgo the period.

    # We can rely on assert 4 == 2+2


Links in Comments
-----------------
Where hyperlinks are in comments forgo punctuation.  Put whitespace before and a newline after.

    No:
        # Look it up on http://google.com/.

        # Go to "http://google.com/" and look it up.    
    
        # This is from http://google.com/:
        #   some content

    Yes:
        # Look it up on http://google.com/

        # Go to http://google.com/
        # and look it up.

        # This is from http://google.com/
        #   some content

        
D.R.Y. (Don't Repeat Yourself) Counterpoint
-------------------------------------------
Rationale:
    The big value of D.R.Y. is avoiding bugs when someday only one part of a repeated feature gets edited.
    The tiny value of D.R.Y. is less typing.

Example:
    DIRECTORY = '/var/etc/'
    :
    :
    def full_path(name):
        return DIRECTORY + name
    assert '/var/etc/name' == full_path('name')
    
Crime:
    '/var/etc/' is repeated.  It must be maintained in two places.
    
Counterpoint (why you may prefer to repeat yourself in this example):
    This case doesn't have the big D.R.Y. problem for long because a skewed edit would be caught by the assert.
    The benefit of repeating yourself here is comprehensible and trustable code.


Don't point guns at feet
------------------------
Not even unloaded.
In line with Extreme Programming (aka Agile?) principles, focus on the task at hand.  Don't anticipate.
But an exception to that is to avoid setting yourself up for future heartache.
For example, avoid jQuery .html() because it's one step toward an injection attack.
    Even if 100% safe today, it can be a setup for future foot-shooting.  
    Because the other steps that open you up to injection attacks can happen far from the .html() call.
For example, clear intentions well-expressed are more important than clever shortcuts
    that could be misunderstood later.  Or discourage future evolution.


" ! " not-operator spacing
--------------------------
JavaScript and C unary 'not' operator should have a space on both sides, so it doesn't get visually lost.

No:
    if (!is_valid)
Yes:
    if ( ! is_valid)

I cringe too, but missing this operator is worse.  Because it changes everything.

Also if someday it were followed consistently (e.g. warning when not done) 
then it would be easier to search for, with " ! ".


Simple
======
Avoid:
    plural
    suffix (ly, ed, er, tion)
    abbreviate
    double negative
    ambiguity
    low-content words ("the", "system", prepositions)
unless
    avoiding would be nonsensical, or
    avoiding could be confusing, or
    there's some other good reason, or
    it's very funny

        

Naming
======
...is very important.

2 > 3
-----
No:
    url_for_login
Yes:
    url_login
    

significance first
specificity first
-----------------
No:
    url_login
Yes:
    login_url
    
    
plural <- avoid
plural names only for arrays
----------------------------
That is, an instance of a collection class.  Such as an array in JavaScript, or a list or set in Python.

No:
    NAV_BUTTONS_ELEMENT
Yes:
    NAV_BUTTON_ELEMENT
    
Yes:
    product_names = list()
    :
    for product_name in product_names:
        sell(product_name)

Avoid confusion as to whether a name is plural.
Support Python looping like this:  "for thing in things"
    But not for dictionaries
        Misleading:
            for variable in variables
        Corrected:
            for name, value in variables.items()
        Better:
            for name, value in variable_dictionary.items()

No:
    utility_functions.js   // nearly every JavaScript source file has functions
No: 
    utilities.js   // avoidable plural (name the purpose, not the content)
Yes:
    utility.js
    
    
SEE:  Singular table names, https://stackoverflow.com/a/5841297/673991
      Plural table names, https://stackoverflow.com/a/3254185/673991
    

        
English is better than abbreviations
------------------------------------
From PEP8, "Identifiers ... SHOULD use English words wherever feasible."

Example:  latitude is better than lat


It's All A "Test"
-----------------
Vague vacuous words are dangerous.
All life is a test.  
The parts that are tests today are different than the parts that will be tests tomorrow.
Failures become rehearsals.  And tests turn out to need testing too.
The word is a moving target.
Only unit tests should be called SomethingTest or test_something.
And nothing should ever be called just "test".


Futz with the variable, futz with the name
------------------------------------------
No:
    def function(parameter):
        parameter = cleaner(parameter)   # <-- works for now, but confusion and bugs are more likely later
        work_with(parameter)
Yes:
    def function(parameter_dirty):
        parameter = cleaner(parameter_dirty)
        work_with(parameter)

No:
    def f(x, y=None):
        y = y or Y_DEFAULT           # <-- Now "y" has two different meanings.  It lies.
        do_stuff(y)
Yes:
    def f(x, y_maybe_none=None):     # This could be a problem for callers, in named-parameter languages.
        y = y_maybe_none or Y_DEFAULT
        do_stuff(y)
Maybe:
    def f(x, y=None):                # You may be constrained naming the raw input, e.g. if you want callers to be able to f(1, y=2)
        y_improved = y or Y_DEFAULT
        do_stuff(y_improved)         # But this is prone to problems later, if someone does_something_with(y)
Also yes:
    def f(x, y=None):
        but_y_could_be_none = y      # Crazy?  Offense is useful when you want extra attention.  Like when you need to lie but you wish to confess right away.  Better than misleading.
        y = but_y_could_be_none or Y_DEFAULT
        do_stuff(y)


Single-letter names
-------------------
Good in tightly coupled code.  Bad when scope spans more than a few lines.

Good in Python comprehensions:

    names = [ sanitize(n) for n in names_unsanitary ]

Good in the first few lines of a loop, where meaning is clear:

    for t in transactions:
        if t.id() == identifier:
            return t


UUIDs should be rarely seen and never pasted
--------------------------------------------
I noticed once when I was cutting and pasting UUIDs that it felt wrong. 
Turned out it was.  When I eventually used them it their handling was automted.
I could see them in ultra-internal contexts, but I never had to cut and paste them.
But I haven't worked with them much.



Brevity is Good; Clarity is Greater (bg;CG)
===========================================


One Line, One Idea
------------------
No:
    import os, sys
Yes:
    import os
    import sys

No:
    a[i++] = x;
Yes:
    a[i] = x;
    i++;

(Thanks, https://stackoverflow.com/a/971442/673991)

No:
    var a,b=2;
Yes:
    var a;
    var b=2;
    
    
Line Bites
----------
For comprehension, simple is better than brief.

Meh:
    return cache.setdefault(x, f(x))
    # f() is always called!
Better:
    try:
        y = cache[x]
    except KeyError:
        y = f(x)
        cache[x] = y
    return y
Better yet:
    if x not in cache:
        cache[x] = f(x)
    return cache[x]

(Thanks, http://stackoverflow.com/a/36031293/673991)
    


Conditional Expressions - one idea max.
-----------------------
Yes:
    name = 'Jane Doe' if stiff.name is None else stiff.name
Better?
    name = 'Jane Doe'   if stiff.name is None   else stiff.name

No:
    a = (b ? c : (d ? e : f));
Yes:
    if (b) {
        a = c;
    } else if (d) {
        a = e;
    } else {
        a = f;
    }

Nope:
    a = c if b else e if d else f
Not even:
    a = c if b else (e if d else f)
Yes:
    if b:
        a = c
    elif d:
        a = e
    else:
        a = f



Dictionaries and Lists
----------------------

Okay:
    d = {}
    l = []
Better:
    d = dict()
    l = list()

This is an example of readability trumping brevity.
Or possibly a clarification on what brevity means.
Brevity is less about characters and more about visual atoms.
A four-letter-word is atomic to the visual cortex of a literate person.  
Actually, "dict" is not an English word, but it becomes as good as one with Python fluency.
Punctuation symbols may actually be more verbose, in terms of recognition cost.

Anyway, there could be a high cost for misreading {} for () or []. 
It's unfortunate the symbols differ by just a few pixels.
A benevolent developer will only use curly braces where they could not be misunderstood.

Fine:
    d = {'This': 'is more obviously a dictionary.'}
    l = ['This', 'is more obviously a list.']
    
If you think the improvement is meager, just imagine twenty years from now, your eyesight half as good.  
Will you still be coding then?  Some of us will.  Be kind.

Also there's the baked-in confusion that {0} is a set but {} is a dict.
Not to mention () and [] are empty containers, but [0] is a list and (0) is a plain, uncontained zero.
So this is a little silly, but it sure is unambiguous:  

    t = tuple((1,2,3))

Fine:  (redundant typing)
    t = tuple((1,2,3))
    d = dict({'a':1, 'b':2})
    l = list([1,2,3])
    s = set({1,2,3})
Meh:  (tuple initializers)
    d = dict((('a',1), ('b',2)))
    l = list((1,2,3))
    s = set((1,2,3))
Okay:  (native symbols)
    d = {'a':1, 'b':2}
    l = [1,2,3]
    s = {1,2,3}
No:  (misleading typing)
    t = tuple([1,2,3])
    d = dict([['a',1], ['b',2]])
    s = set([1,2,3])



One Space Two Space, Red Space Blue Space
-----------------------------------------
One space after sentence-ending periods and list-starting colons in proportional-spaced fonts.
Two spaces after sentence-ending periods* and list-starting colons in monospaced fonts.

* Agrees with PEP8, as most source code is viewed monospace.



Code comments prescribe:  declarative, present-tense sentences for code behavior  (PEP 257)
Commit comments chronicle:  past tense sentences for human-developer behavior (present tense for code behavior? I guess)
--------------------------

Code comment
    No:
        # Adds two numbers
    Yes:
        # Add two numbers

Code comments should say what the code does, as if the code itself were speaking.
Almost in the first person, but omit the subject.
Even though code is not written in a spoken language, you want to be fluent enough that it still "speaks" to you.
Comments should NOT resemble a human-writer talking to a human reader *about* the code.
It should resemble the computer voicing what it's doing and why, as it's executing the code.
(My interpretation of the intent of PEP 257.)
        
Commit comment
    No:
        -m "Support utf8mb4"
    Nah:
        -m "Supports utf8mb4"
    Meh:
        -m "Supported utf8mb4"
    Better:
        -m "Added support for utf8mb4"

Commit comments are about a happening that was decidedly NOT automated.  (Today anyway!)
It should be in the developer's voice, not the code's.



Units conversions should be isolated
------------------------------------
Many sad stories result from unit confusion. 
Unit conversions should stand out on their own line. 
Variables should be named with units.



Interdependencies should be near
--------------------------------
Ad hoc variables should be declared as close as possible to where they're used.
OOP can be a bureaucracy where many functions do little but call another function, in another file.
MVC is another kind of referential hell.


    
Codetags (PEP 0350, but I use them in all code)
--------

Codetags should go on the line *after* the code they are tagging.
This location resembles putting the codetag comment on the same line as the code,
while complying with the rule "It should not share a line with code."

    y = f(x)
    # NOTE:  This code functions.

Exceptions should be clear, e.g. a codetag ending in a colon ":" applies to lines that follow.

    # NOTE:  Sequence records correctly:
    print("Record sequence", ", ".join(records.keys()))

A codetag should span exactly one line.  Indented continuation lines may elaborate.

    # NOTE:  This is a summary.
    #        More lines may
    #        elaborate.

No <> fields.

Mnemonics I have used from the standard list:
    CAUTION (instead of CAVEAT or WARNING or DANGER or PANIC or HYSTERIA)
    DONE
    FIXME
    HACK
    NOTE (instead of N.B.)
    SEE (instead of SOURCE or REF or REFERENCE)
    THANKS (instead of CREDIT)
    NOTHANKS (seemed helpful but was wrong or misleading)
    THANKS 30% (30% helpful, 70% hindrance)
    TODO
    TODO ... that ends in a question mark?  (THINK?  CONSIDER?  Either change code or change thinking.)
    XXX
    
Additional mnemonics:
    DEBATE (Like multiple TODO's with a question-mark, except they're mutually exclusive.)
        blank lines before and after 
        counterarguments separated by a blank line
    EXAMPLE (output, error message, etc.)
    KUDOS (stronger THANKS)
    REPORTED (noted for posterity, bug report, Q&A submitted by author)
    FALSE WARNING (show text of a warning message, just before the noinspection directive to disable it)
        A response to the unending torrent of PyCharm false alarms.
    STUCK WARNING
        A warning that cannot be disabled.
        A response to the insidious new PyCharm twist where they don't deign to LET you disable some warning of theirs.


Variations
    THANKS:  (maybe)  Some article on stack overflow I do not dare upvote until I know if it works. 
             Because of dumb policy on tactical-down-voting, https://meta.stackexchange.com/a/18046/209317

Possibilities:
    ASSUMPTION  (NOTE is probably good enough.  Even better:  assert.)

    
Continuation lines are indented to line up with the stuff after the colon:
    No:
        // NOTE:  The rain in Spain falls mainly
        // in the plain.
    Yes:
        // NOTE:  The rain in Spain falls mainly
        //        in the plain.



English Coding Style
====================
Less
    first person
    adverb
    contraction
    plural
    words
        Notice if I hadn't made "words" plural it would have been very hard to understand.
            Notice I've shamelessly violated all five of the above rules in that sentence.
                That one too.
    idiom
    confusion
    contempt

More
    incitement
    humor


(Not advocating less pretense or more authenticity. Legislating morality or something.)
